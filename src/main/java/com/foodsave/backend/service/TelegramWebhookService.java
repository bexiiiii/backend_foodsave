package com.foodsave.backend.service;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.foodsave.backend.dto.telegram.TelegramCallbackQuery;
import com.foodsave.backend.dto.telegram.TelegramMessage;
import com.foodsave.backend.dto.telegram.TelegramUpdate;
import com.foodsave.backend.dto.telegram.TelegramUser;
import com.foodsave.backend.dto.telegram.TelegramWebAppData;
import com.foodsave.backend.entity.Order;
import com.foodsave.backend.entity.OrderItem;
import com.foodsave.backend.entity.Product;
import com.foodsave.backend.entity.Store;
import com.foodsave.backend.entity.User;
import com.foodsave.backend.domain.enums.OrderStatus;
import com.foodsave.backend.domain.enums.PaymentMethod;
import com.foodsave.backend.domain.enums.PaymentStatus;
import com.foodsave.backend.repository.OrderRepository;
import com.foodsave.backend.exception.InsufficientStockException;
import com.foodsave.backend.repository.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Locale;
import java.util.concurrent.ThreadLocalRandom;
import java.math.BigDecimal;

@Service
@RequiredArgsConstructor
@Slf4j
public class TelegramWebhookService {

    private final TelegramBotService telegramBotService;
    private final ObjectMapper objectMapper;
    private final UserRepository userRepository;
    private final OrderRepository orderRepository;
    private final ProductService productService;

    @Value("${telegram.miniapp.base-url:https://miniapp.foodsave.kz}")
    private String miniAppBaseUrl;

    @Value("${telegram.support.username:@FoodSave_kz}")
    private String supportUsername;

    private static final DateTimeFormatter RESERVATION_TIME_FORMAT =
            DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm", new Locale("ru"));
    private static final ZoneId DEFAULT_TIME_ZONE = ZoneId.of("Asia/Almaty");

    @Transactional
    public void handleUpdate(TelegramUpdate update) {
        if (update == null) {
            return;
        }

        log.info("Received Telegram update: messageId={}, hasCallback={}, hasWebAppData={}",
                update.message() != null ? update.message().messageId() : null,
                update.callbackQuery() != null,
                (update.message() != null && update.message().webAppData() != null)
                        || (update.callbackQuery() != null && update.callbackQuery().webAppData() != null));

        TelegramMessage message = resolveMessage(update);
        TelegramUser from = resolveUser(update);
        Long chatId = resolveChatId(message);

        if (chatId == null) {
            log.warn("Received Telegram update without chat id: {}", update);
            return;
        }

        if (handleWebAppData(update, message, from, chatId)) {
            return;
        }

        if (message != null && message.text() != null) {
            handleTextMessage(message.text(), chatId, from);
        }
    }

    private TelegramMessage resolveMessage(TelegramUpdate update) {
        if (update.message() != null) {
            return update.message();
        }
        TelegramCallbackQuery callbackQuery = update.callbackQuery();
        if (callbackQuery != null) {
            return callbackQuery.message();
        }
        return null;
    }

    private TelegramUser resolveUser(TelegramUpdate update) {
        if (update.message() != null && update.message().from() != null) {
            return update.message().from();
        }
        TelegramCallbackQuery callbackQuery = update.callbackQuery();
        if (callbackQuery != null) {
            if (callbackQuery.webAppData() != null && callbackQuery.from() != null) {
                return callbackQuery.from();
            }
            TelegramMessage message = callbackQuery.message();
            if (message != null) {
                return message.from();
            }
        }
        return null;
    }

    private Long resolveChatId(TelegramMessage message) {
        if (message != null && message.chat() != null) {
            return message.chat().id();
        }
        return null;
    }

    private boolean handleWebAppData(TelegramUpdate update,
                                      TelegramMessage message,
                                      TelegramUser from,
                                      Long chatId) {
        TelegramWebAppData webAppData = null;
        if (message != null && message.webAppData() != null) {
            webAppData = message.webAppData();
        } else if (update.callbackQuery() != null) {
            webAppData = update.callbackQuery().webAppData();
        }

        if (webAppData == null || webAppData.data() == null || webAppData.data().isBlank()) {
            return false;
        }

        try {
            ReservationPayload payload = objectMapper.readValue(webAppData.data(), ReservationPayload.class);
            log.info("Processing web_app_data reservation for chat {}: action={}, productId={}, quantity={}",
                    chatId, payload.action(), payload.productId(), payload.quantity());
            respondToReservation(chatId, from, payload);
        } catch (Exception e) {
            log.error("Failed to parse web_app_data: {}", webAppData.data(), e);
            telegramBotService.sendMessage(chatId, new TelegramBotService.TelegramMessagePayload(
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",
                    null,
                    null,
                    null
            ));
        }
        return true;
    }

    private void handleTextMessage(String text, Long chatId, TelegramUser from) {
        String trimmed = text.trim();
        if (trimmed.isEmpty()) {
            return;
        }

        String command = trimmed.split("\\s+")[0];

        log.info("Handling text command '{}' from chat {} (user={})", command, chatId,
                from != null ? from.id() : null);

        if (command.equalsIgnoreCase("/start") || command.toLowerCase(Locale.ROOT).startsWith("/start@")) {
            sendWelcomeMessage(chatId);
            return;
        }

        if (command.equalsIgnoreCase("/help") || command.toLowerCase(Locale.ROOT).startsWith("/help@")) {
            sendSupportMessage(chatId);
            return;
        }

        // Fallback for any other text input
        telegramBotService.sendMessage(chatId, new TelegramBotService.TelegramMessagePayload(
                "–ß—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –±–æ–∫—Å —Å–æ —Å–∫–∏–¥–∫–æ–π, –æ—Ç–∫—Ä–æ–π—Ç–µ –º–∏–Ω–∏‚Äë–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ FoodSave –∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å¬ª –Ω–∞ –Ω—É–∂–Ω–æ–º —Ç–æ–≤–∞—Ä–µ.",
                null,
                null,
                null
        ));
    }

    private void sendWelcomeMessage(Long chatId) {
        String welcomeText = String.join("\n",
                "–ü—Ä–∏–≤–µ—Ç! üëã",
                "–Ø –±–æ—Ç FoodSave.",
                "–û—Ç–∫—Ä–æ–π –º–∏–Ω–∏‚Äë–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –∫–æ—Ä–æ–±–∫—É —Å–æ —Å–∫–∏–¥–∫–æ–π –∏ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –µ—ë.");

        String webAppUrl = ensureHttps(miniAppBaseUrl);
        telegramBotService.sendWebAppMessage(chatId, welcomeText, "–û—Ç–∫—Ä—ã—Ç—å FoodSave Mini App", webAppUrl);
    }

    private void sendSupportMessage(Long chatId) {
        String supportText = String.join("\n",
                "–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å? –ú—ã –≤—Å–µ–≥–¥–∞ –Ω–∞ —Å–≤—è–∑–∏!",
                "–ù–∞–ø–∏—à–∏—Ç–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: @FoodSave_kz ",
                "–ò–ª–∏ –æ—Ç–∫—Ä–æ–π—Ç–µ –º–∏–Ω–∏‚Äë–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, —á—Ç–æ–±—ã –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑ –∑–∞–Ω–æ–≤–æ.");

        telegramBotService.sendMessage(chatId, new TelegramBotService.TelegramMessagePayload(
                supportText,
                null,
                null,
                null
        ));
    }

    private void respondToReservation(Long chatId, TelegramUser from, ReservationPayload payload) {
        ReservationResult reservationResult = createReservationOrder(from, payload);
        if (!reservationResult.success()) {
            telegramBotService.sendMessage(chatId, new TelegramBotService.TelegramMessagePayload(
                    reservationResult.errorMessage(),
                    null,
                    null,
                    null
            ));
            return;
        }

        Order order = reservationResult.order();
        String reserverName = from != null ? from.displayName() : "–≤–∞—Å";
        String formattedTotal = formatPrice(order.getTotal().doubleValue());
        String formattedUnit = formatPrice(order.getItems().get(0).getUnitPrice().doubleValue());
        String formattedTime = formatTimestamp(payload.timestamp());

        Product product = reservationResult.product();
        Store store = product.getStore();

        StringBuilder messageBuilder = new StringBuilder();
        messageBuilder.append("üßæ –ó–∞–∫–∞–∑ ‚Ññ").append(order.getOrderNumber()).append("\n");
        messageBuilder.append("–ë–æ–∫—Å: ").append(orUnknown(product.getName())).append("\n");
        messageBuilder.append("–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ").append(orUnknown(store.getName())).append("\n");
        if (store.getAddress() != null && !store.getAddress().isBlank()) {
            messageBuilder.append("–ê–¥—Ä–µ—Å: ").append(store.getAddress()).append("\n");
        }
        messageBuilder.append("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ").append(order.getItems().get(0).getQuantity()).append(" —à—Ç.").append("\n");
        messageBuilder.append("–¶–µ–Ω–∞ –∑–∞ —à—Ç.: ").append(formattedUnit).append("\n");
        messageBuilder.append("–°—É–º–º–∞: ").append(formattedTotal).append("\n");
      

        if (formattedTime != null) {
            messageBuilder.append("\n–í—Ä–µ–º—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: ").append(formattedTime);
        }

        messageBuilder.append("\n\n–ó–∞–∫–∞–∑ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω –∑–∞ ").append(reserverName).append(".  –ï—Å–ª–∏ –ø–æ—è–≤—è—Ç—Å—è –≤–æ–ø—Ä–æ—Å—ã ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /help.");

        telegramBotService.sendMessage(chatId, new TelegramBotService.TelegramMessagePayload(
                messageBuilder.toString(),
                null,
                null,
                null
        ));

        User user = order.getUser();
        log.info("Reservation confirmation sent for order {} (telegram user={}, chat={})",
                order.getOrderNumber(), user != null ? user.getId() : null, chatId);
    }

    private String formatPrice(double value) {
        return String.format(Locale.US, "%,.0f ‚Ç∏", value).replace(',', ' ');
    }

    private String formatTimestamp(String timestamp) {
        if (timestamp == null || timestamp.isBlank()) {
            return null;
        }
        try {
            Instant instant = Instant.parse(timestamp);
            return RESERVATION_TIME_FORMAT.format(instant.atZone(DEFAULT_TIME_ZONE));
        } catch (DateTimeParseException ignored) {
            try {
                OffsetDateTime offsetDateTime = OffsetDateTime.parse(timestamp);
                return RESERVATION_TIME_FORMAT.format(offsetDateTime.atZoneSameInstant(DEFAULT_TIME_ZONE));
            } catch (DateTimeParseException ignoredOffset) {
                try {
                    LocalDateTime localDateTime = LocalDateTime.parse(timestamp);
                    return RESERVATION_TIME_FORMAT.format(localDateTime.atZone(DEFAULT_TIME_ZONE));
                } catch (DateTimeParseException ex) {
                    log.debug("Unable to parse reservation timestamp: {}", timestamp, ex);
                    return null;
                }
            }
        }
    }

    private String ensureHttps(String url) {
        if (url == null || url.isBlank()) {
            return "https://miniapp.foodsave.kz";
        }
        if (url.startsWith("http://")) {
            return "https://" + url.substring(7);
        }
        return url;
    }

    private String generateOrderNumber() {
        int random = ThreadLocalRandom.current().nextInt(0, 1_000_000);
        return String.format("%06d", random);
    }

    private String orUnknown(String value) {
        if (value == null || value.isBlank()) {
            return "–Ω–µ —É–∫–∞–∑–∞–Ω–æ";
        }
        return value;
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    private record ReservationPayload(
            String action,
            Long productId,
            String productName,
            String storeName,
            int quantity,
            double unitPrice,
            double totalPrice,
            String timestamp,
            String message
    ) {
    }

    private record ReservationResult(boolean success, Order order, Product product, String errorMessage) {
    }

    private ReservationResult createReservationOrder(TelegramUser from, ReservationPayload payload) {
        if (payload.productId() == null) {
            return new ReservationResult(false, null, null, "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –º–∏–Ω–∏‚Äë–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
        }

        int requestedQuantity = Math.max(payload.quantity(), 1);

        User user = null;
        if (from != null && from.id() != null) {
            user = userRepository.findByTelegramUserId(from.id()).orElse(null);
        }

        if (user == null) {
            log.warn("Reservation attempted without linked user. telegramId={} payload={}" ,
                    from != null ? from.id() : null, payload);
            return new ReservationResult(false, null, null, "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å. –û—Ç–∫—Ä–æ–π—Ç–µ –º–∏–Ω–∏‚Äë–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ FoodSave –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –±–æ—Ç–∞ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.");
        }

        Product product;
        try {
            product = productService.reserveProductStock(payload.productId(), requestedQuantity);
        } catch (EntityNotFoundException ex) {
            log.warn("Reservation failed: product {} not found", payload.productId());
            return new ReservationResult(false, null, null, "–í—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç –±–æ–ª—å—à–µ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∫–æ—Ä–æ–±–∫—É.");
        } catch (InsufficientStockException ex) {
            log.warn("Reservation failed: insufficient stock for product {} (requested={} telegramId={})",
                    payload.productId(), requestedQuantity, from != null ? from.id() : null);
            return new ReservationResult(false, null, null, "–£–ø—Å! –ö–æ—Ä–æ–±–∫–∞ —É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å. –í—ã–±–µ—Ä–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥—Ä—É–≥—É—é –ø–æ–∑–∏—Ü–∏—é.");
        } catch (IllegalArgumentException ex) {
            log.warn("Reservation failed: invalid quantity {} for product {}", requestedQuantity, payload.productId(), ex);
            return new ReservationResult(false, null, null, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —É–∫–∞–∑–∞–Ω–æ –Ω–µ–≤–µ—Ä–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.");
        }

        Order order = new Order();
        order.setUser(user);
        order.setStore(product.getStore());
        order.setOrderNumber(generateUniqueOrderNumber());
        order.setStatus(OrderStatus.PENDING);
        order.setPaymentStatus(PaymentStatus.PENDING);
        order.setPaymentMethod(PaymentMethod.CASH);
        order.setContactPhone(orFallbackPhone(user.getPhone()));
        order.setDeliveryAddress(product.getStore() != null ? product.getStore().getAddress() : null);
        order.setDeliveryNotes(payload.message() != null ? payload.message() : "Telegram –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ");

        OrderItem item = new OrderItem();
        item.setOrder(order);
        item.setProduct(product);
        item.setQuantity(requestedQuantity);

        BigDecimal unitPrice = payload.unitPrice() > 0
                ? BigDecimal.valueOf(payload.unitPrice())
                : (product.getPrice() != null ? product.getPrice() : BigDecimal.ZERO);

        item.setUnitPrice(unitPrice);
        item.calculateTotalPrice();

        order.addItem(item);
        order.calculateTotals();

        Order savedOrder = orderRepository.save(order);

        log.info("Order {} successfully saved for telegram user {} (product {} store {})",
                savedOrder.getOrderNumber(), user.getId(), product.getId(),
                product.getStore() != null ? product.getStore().getId() : null);

        return new ReservationResult(true, savedOrder, product, null);
    }

    private String generateUniqueOrderNumber() {
        String orderNumber;
        do {
            orderNumber = generateOrderNumber();
        } while (orderRepository.existsByOrderNumber(orderNumber));
        return orderNumber;
    }

    private String orFallbackPhone(String phone) {
        if (phone == null || phone.isBlank()) {
            return "+7 000 000 0000";
        }
        return phone;
    }
}
